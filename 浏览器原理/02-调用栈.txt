为什么JavaScript代码会出现栈溢出

符合规范的代码
    1. 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上
       下文只有一份。
    2. 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数
       执行上下文会被销毁。
    3. 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。

调用栈就是用来管理函数调用关系的一种数据结构。因此要清楚调用栈，先要弄明白函数调用和栈结构。

什么是函数调用
函数调用就是运行一个函数

函数调用的过程
执行到函数之前，JavaScript 引擎会为代码创建全局执行上下文，包含了声明的函数和变量
首先，从全局执行上下文中，取出函数代码。
其次，对函数代码进行编译，并创建该函数的执行上下文和可执行代码。
最后，执行代码，输出结果。
当执行到函数的时候，就有了两个执行上下文了——全局执行上下文和函数的执行上下文。
也就是说在执行 JavaScript 时，可能会存在多个执行上下文，那么 JavaScript 引擎是如何管理这些执行上下文的呢？
答案是通过一种叫栈的数据结构来管理的

什么是栈
先进后出

什么是 JavaScript 的调用栈
JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，
通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。

调用栈是 JavaScript 引擎追踪函数执行的一个机制

调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出


function runStack (n) {
    if (n === 0) return 100;
    return runStack( n- 2);
}
runStack(50000) #栈溢出优化

# 尾递归 个别浏览器依然无效


# 参考
function runStack1 (n) {
    if (n === 0) return 100;
    return runStack.bind(null,n-2)();
}
runStack1(50000)