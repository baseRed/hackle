1. http常见请求头

    Accept Accept-Chartset Accept-Encoding 
    Cache-Control
    Connection
    Cookie
    Host
    If-Match
    If-Modified-Since
    
2. http常见相应头

    Accept-Control-Allow-Origin
    Cache-Control
    Content-Encoding
    Content-Length
    Content-Langusge
    Date
    Etag
    Exprice
    Last-Modified
    Set-Cookie


3. http缓存

    强缓存

    Exprices 服务端返回的数据到期时间，再次请求时间小于返回的此时间，则直接使用缓存数据
    但客户端和服务端时间可能有差异，导致缓存命中的误差，Expires是HTTP1.0的产物，现在大多
    使用Cache-Control代替

    Cache-Control 有很多属性。
    privite: 客户端可以缓存
    public: 客户端和代理服务器都可以缓存 
    max-age=t: 缓存内容将在t秒后失效
    no-cache: 需要使用协商缓存来验证缓存数据
    no-store: 不使用缓存

    协商缓存

    Last-Modified: 服务器在相应请求时，会告诉客户端资源的最后修改时间
    If-Modified-Since: 浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。
                       服务端收到此请求头发现有If-Modified-Since,则与被请求资源的最后修改时间进行对比，如果
                       一致则返回304和相应报文头，客户端只需从缓存中读取数据即可。字面意思就是：从某个时间点
                       算起，是否文件被修改了
                       
                       1. 如果真的被修改：开始传输相应一个整体，服务器返回：200 OK
                       2. 如果没有被修改： 只需传输响应header,服务器返回： 304 Not Modified

    If-Unmodified-Since: 字面意思即：从某个时间点算起，是否文件没有被修改

                         1. 如果没有被修改：开始‘继续’传送文件 服务器返回： 200 OK
                         2. 如果文件被修改： 不传输 服务器返回： 412 Precondition failed(预处理错误)

    两则区别是： 一个是修改了才下载一个是没修改才下载。

    Last-Modified缺点： 如果在服务器上，一个资源被修改了，但其实际内容根本没有改编，会因为Last-Modified
                        时间匹配不上而返回了整个实体给客户端（即客户端缓存里有一个一模一样的资源）。为了解决
                        这个问题，HTTP1.1推出了Etag   
                        
    Etag: 服务器相应请求时，通过该字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）

    If-None-Match: 再次请求资源时，客户端的请求报文头部会包含该字段，值为缓存中获取的标识。服务器接收到此
                   报文后发现If-None-Match则与被请求资源的唯一标识进行对比
                   
                   1. 不同： 资源被改动过，则相应整个资源内容， 200
                   2. 相同： 资源没有被修改过，则相应header，客户端从缓存中获取数据。 304
    
    Etag缺点： 实际使用中Etag的计算是使用算法来得出的，而算法会占用服务器端计算的资源，所有服务器端的资源都是宝贵的，
              所以很少使用Etag了 

    缓存的优点： 
                1. 减少了冗余的数据传递，节省宽带流量
                2. 减少了服务器的负担，大大提高网站性能
                3. 加快了哭护短加载网页的速度
              
    不同刷新的请求执行过程： 
                1. 浏览器地址栏中输入URL，回车 浏览器发现缓存中有这个文件了，不用继续请求了，直接从缓存取（最快）
                2. F5 告诉浏览器，别偷懒，好歹去服务器看看这个文件是否过期了。于是浏览器就发送了一个带IF-Modified-Since
                   的请求
                3. Ctrl + F5 告诉浏览器，先把缓存中的文件，再去服务器请求个完整的资源下来。于是客户端就完成了更新的操作


4. HTTP keep-alive
    在HTTP1.0时期，每个TCP连接只会被一个HTTP Transaction(请求加相应)使用，请求时建立，请求完成释放连接，当网页内容
    越来越复杂，包含大量图片、CSS等资源之后，这种模式效率就显得太低了。所以，在HTTP1.1中，引入了HTTP keep-alive，目的是
    复用TCP连接，在一个TCP连接上进行多次的HTTP请求从而提升性能

    HTTP1.0中默认是关闭的，需要在HTTP头加入“Connection：Keep-clive”，才能启用Keep-Alive;HTTP1.1中默认启用Keep-Alive
    加入“Connection：close”关闭
